# # Hashes and the key/values of the hash often behave very differently. Keep in
# # mind that the keys and values might not be hashes themselves, so pointing or
# # executing commands on those will result in commands specific to the class of
# # whatever element is pointed at. Hashes should have key-value pairs with a
# # similar type (strings key, array value) instead of different types of key-
# # value pairs.


# # When a hash is the last argument in a method, you can leave behind the curly
# brackets. #The foreach method takes 2 arguments. foreach is called on CSV as a
# way to read through a CSV file; and the argument is the filename (music.csv),
# and then options that we need. For example:

CSV.foreach(@filename, :headers => true) do |row| 
	end

#In this instance, the method will take in the row item in the column
# (referred in the pipe argument) and read it and parse it into the command
# for each row. For example, if you had 2 columns labelled weapon and attack,
# # it would read each row in the CSV under weapon and attack columns and process
# # the method described in do.

#We can check if a particular key exists in a hash with a .key?(key) argument.
#music.key?(artist_name) will check if artist_name is a key in the hash music.
#We can check if a key is NOT in there with !music.key?(artist_name).

#When you make a method that is []=(args), Ruby can interpret things specially
#to for a sugar value. There are a few instances where these methods can
#exist. In this case, instead of writing []=(args), you can perform special
#syntax on the arguments (in this case, variable.[arg1] = "arg 2"). This
#crease a sugar value.

#For understanding hashes: hashes are essentially a key-value pair. We can
#think of them as joined pairs in an array, separating each pair with a comma
#and each pair is made up of a key and value separated by a hash rocket (=>)

class MyHash
	def initialize
		@pairs = []
	end

	def []=(key, value)
		@pairs << Pair.new(key, value)
	end
end

class Pair
	def initialize(key, value)
		@key = key
		@value = value
	end

end

#When you call varname = MyHash.new, it'll create an instance variable array
#called @pairs for the varname instance of MyHash. Then, when
#varname.[keyname]=valuename is done, @pairs' array is pushed with a new @key
#and an @value generated by the Pair.new (giving an @key and an @value).

#Followiing that, the key-value pair needs to be displayed properly. As is, it
#will display a jumble of numbers when returned. To append this, new methods
#will need to be defined (and overwrite default methods in the process)

class MyHash
	...
	...
	...

	def inspect 
		"{ #{@pairs.join(", ")}"

	end
	...
	...
	...
end

class Pair
	...
	...
	...
	def to_s
		"#{@key.inspect} => #{@value.inspect}"
	end
	...
	...
	...
end

# By adding these, inspect redefined will display instances of MyHash when
# called to create a string of items in @pairs joined by ", ", all displayed
# as a string. The redefined to_s on instances of Pair is going to change the
# to_s method to display the key value pair as interpolated. The inspect
# command is important as it displays the result of inspect, instead of
# default interpolation (which returns a string, which isn't correct).

# While that displays things correctly, it still does not behave like a hash
# yet. Hashes need to have specific keys that have values attached, they are
# unique. In this current state, a new pair entered with the same name will
# coexist with the old pair. So things need to be changed in the []= method.

class MyHash
	...
	...
	...

	def []=(key, value)
		matching_pair = find_pair(key)
		if matching_pair
			matching_pair.value = value
		else
			@pairs << Pair.new(key, value)
		end
	end
	...
	...
	...
end


#With this, we need to define 2 new methods; find_pair and a new setter method (which gives syntatic sugar).

class Pair
	..
	...
	...

	def value=(new_value)
		@value = new_value
	end

	...
	...
	...
end

# This setter method is simple: it turns @value into a new_value, whatever is
# called on it. If we look at the []= method, we'll see that
# matching_pair.value = value. This is the syntatic sugar. Normally, it would
# be matching_pair.value=(value), but the sugar makes it easy. This method is
# also important because this is the only way we can change the contents of
# @value into the new value. (This is the function of a setter value)

class MyHash

	...
	...
	...

	def find_pair(key)
		@pairs.find { |pair| pair.key == key }
	end

	...
	...
end

class Pair
	...
	...
	...

	def key
		@key
	end
	...
	...
	...
end


#.find is a command used to search through items in the pairs to find the
#.first matching item if specified in the block itself and expects a
#.true/false on the block - it'll look for the first true case.. In this case,
#.|pair| refers to the Pair object (which contains our pair), and pair.key
#.will just simply get the @key of the pair item and compare it with the key
#.defined in the argument of find_pair. This is the getter method.

# Now, this will make the hash function like a real hash! ...almost.
# A setter will change the value of an instance variable with the same name. 
# A getter will return the value of an instance variable with the same name.

#We can use attr_reader :(instancevariablename) to do the same thing as a
#getter - define a whole method just like that. On the other hand, we have
#attr_writer :(instancevariablename) to do the same thing as a setter  and
#define a method just like that. No parentheses are required for either even
#though both are methods - they are just so common the argument parentheses
#aren't needed. Make sure that the symbols are the same as your @instancevars.
#These two should go above the initialize.

#Now, we need to be able to get the value of the key that is stored. In normal
#hashes, we can use hashname[key] to return the value. So to do that we need
#to write more code to define it - [], as we seen is already a method! But it
#needs to be defined.

class MyHash
	...
	...
	...
	def [](key)
		matching_pair = find_pair(key)
	end
	...
	...
	...
end


